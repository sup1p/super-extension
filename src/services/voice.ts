export class VoiceService {
    static initVoice(doc: Document): void {
        const button = doc.getElementById("voice-rec-btn") as HTMLButtonElement;
        const output = doc.getElementById("voice-result") as HTMLParagraphElement;
        const bar = doc.getElementById("voice-level") as HTMLDivElement;
        let manualClose = false;

        const WV_URL = 'ws://localhost:8000/websocket-voice';
        let wv: WebSocket | null = null;
        let rec: MediaRecorder | null = null;
        let stream: MediaStream | null = null;
        let chunks: BlobPart[] = [];
        let isListening = false;
        let isPlaying = false;
        let currentAudio: HTMLAudioElement | null = null;

        // –î–µ—Ç–µ–∫—Ü–∏—è –º–æ–ª—á–∞–Ω–∏—è
        let silenceTimer: NodeJS.Timeout | null = null;
        let audioContext: AudioContext | null = null;
        let analyser: AnalyserNode | null = null;
        let dataArray: Uint8Array | null = null;
        let lastSoundTime = 0;
        let silenceCheckInterval: NodeJS.Timeout | null = null;

        const SILENCE_THRESHOLD = 120;
        const SILENCE_DURATION = 2000;
        const CHECK_INTERVAL = 100;
        const MIN_AUDIO_DURATION = 500;
        const MAX_AUDIO_DURATION = 30000;
        let recordingStartTime = 0;

        const connectWS = () => {
            wv = new WebSocket(WV_URL);

            wv.onopen = () => {
                console.log('WebSocket –ø–æ–¥–∫–ª—é—á–µ–Ω');
                button.disabled = false;
                button.textContent = 'üéôÔ∏è Start Listening';
                output.textContent = '–ì–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ';
            };

            wv.onmessage = (e) => {
                const { text, audio_base64 } = JSON.parse(e.data);
                output.textContent = text;

                if (audio_base64) {
                    playResponse(audio_base64);
                }
            };

            wv.onclose = () => {
                console.log('WebSocket –∑–∞–∫—Ä—ã—Ç');
                wv = null;
                if (!manualClose) {
                    console.log("–ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–Ω–∏–µ");
                    setTimeout(connectWS, 1000);
                }
            };
        };

        const setupMicrophone = async () => {
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        channelCount: 1,
                        sampleRate: 16000
                    }
                });

                audioContext = new AudioContext({
                    sampleRate: 16000
                });
                analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);

                const filter = audioContext.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 300;
                source.connect(filter);
                filter.connect(analyser);

                analyser.fftSize = 1024;
                analyser.smoothingTimeConstant = 0.8;
                const bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);

                rec = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus',
                    audioBitsPerSecond: 16000
                });

                rec.ondataavailable = e => {
                    if (e.data.size > 0) chunks.push(e.data);
                };

                rec.onstop = () => {
                    if (!isListening || isPlaying) return;

                    const recordingDuration = Date.now() - recordingStartTime;

                    if (recordingDuration < MIN_AUDIO_DURATION) {
                        console.log('–ó–∞–ø–∏—Å—å —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∞—è, –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º');
                        chunks = [];
                        return;
                    }

                    if (recordingDuration > MAX_AUDIO_DURATION) {
                        console.log('–ó–∞–ø–∏—Å—å —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–∞—è, –æ–±—Ä–µ–∑–∞–µ–º');
                        chunks = chunks.slice(-1);
                    }

                    console.log('–ó–∞–ø–∏—Å—å –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞, –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:', recordingDuration, '–º—Å');

                    if (chunks.length > 0) {
                        const blob = new Blob(chunks, { type: 'audio/webm' });
                        if (blob.size > 1000) {
                            sendAudio(blob);
                        } else {
                            console.log('–ê—É–¥–∏–æ —Å–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–æ–µ, –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º');
                        }
                    }
                    chunks = [];

                    if (isListening && !isPlaying) {
                        setTimeout(() => {
                            if (rec && isListening && !isPlaying) {
                                console.log('–ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ –∑–∞–ø–∏—Å–∏');
                                rec.start();
                                recordingStartTime = Date.now();
                            }
                        }, 100);
                    }
                };

                return true;
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É:', error);
                return false;
            }
        };

        const sendAudio = async (blob: Blob) => {
            if (wv && wv.readyState === WebSocket.OPEN) {
                console.log('–û—Ç–ø—Ä–∞–≤–∫–∞ –∞—É–¥–∏–æ, —Ä–∞–∑–º–µ—Ä:', blob.size);
                const arrayBuffer = await blob.arrayBuffer();
                wv.send(arrayBuffer);
            }
        };

        const playResponse = (audioBase64: string) => {
            console.log('–ù–∞—á–∞–ª–æ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –æ—Ç–≤–µ—Ç–∞');

            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }

            if (rec && rec.state === 'recording') {
                rec.stop();
                chunks = [];
            }

            stopSilenceDetection();

            isPlaying = true;
            currentAudio = new Audio('data:audio/mp3;base64,' + audioBase64);

            currentAudio.onended = () => {
                console.log('–í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ');
                isPlaying = false;
                currentAudio = null;

                if (isListening && rec) {
                    setTimeout(() => {
                        if (isListening && !isPlaying) {
                            console.log('–í–æ–∑–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –ø–æ—Å–ª–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è');
                            rec!.start();
                            startSilenceDetection();
                        }
                    }, 200);
                }
            };

            currentAudio.onerror = () => {
                console.error('–û—à–∏–±–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è');
                isPlaying = false;
                currentAudio = null;

                if (isListening && rec) {
                    rec.start();
                    startSilenceDetection();
                }
            };

            currentAudio.play().catch(console.error);
        };

        const getAudioLevel = (): number => {
            if (!analyser || !dataArray) return 0;

            analyser.getByteFrequencyData(dataArray);

            let sum = 0;
            let count = 0;

            const startFreq = Math.floor(dataArray.length * 0.1);
            const endFreq = Math.floor(dataArray.length * 0.5);

            for (let i = startFreq; i < endFreq; i++) {
                if (dataArray[i] > 0) {
                    sum += dataArray[i] * dataArray[i];
                    count++;
                }
            }

            return count > 0 ? Math.sqrt(sum / count) : 0;
        };

        const checkSilence = () => {
            if (!isListening || isPlaying) return;

            const audioLevel = getAudioLevel();
            const currentTime = Date.now();

            if (bar) {
                const percent = Math.min(100, (audioLevel / 256) * 100);
                bar.style.width = percent + "%";
                if (percent < 30) {
                    bar.style.background = '#ff4444';
                } else if (percent < 70) {
                    bar.style.background = '#ffbb33';
                } else {
                    bar.style.background = '#00C851';
                }
            }

            if (audioLevel > SILENCE_THRESHOLD) {
                lastSoundTime = currentTime;
                if (silenceTimer) {
                    clearTimeout(silenceTimer);
                    silenceTimer = null;
                }
            } else {
                if (lastSoundTime > 0) {
                    const silenceDuration = currentTime - lastSoundTime;
                    if (silenceDuration >= SILENCE_DURATION) {
                        processSilence();
                    } else if (!silenceTimer) {
                        const remainingTime = SILENCE_DURATION - silenceDuration;
                        silenceTimer = setTimeout(processSilence, remainingTime);
                    }
                }
            }
        };

        const processSilence = () => {
            console.log('–û–±—Ä–∞–±–æ—Ç–∫–∞ –º–æ–ª—á–∞–Ω–∏—è - –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–ø–∏—Å—å');

            if (silenceTimer) {
                clearTimeout(silenceTimer);
                silenceTimer = null;
            }

            if (rec && rec.state === 'recording') {
                rec.stop();
                chunks = [];
            }

            lastSoundTime = 0;
        };

        const startSilenceDetection = () => {
            console.log('–ù–∞—á–∞–ª–æ –¥–µ—Ç–µ–∫—Ü–∏–∏ –º–æ–ª—á–∞–Ω–∏—è');
            lastSoundTime = Date.now();

            if (silenceCheckInterval) {
                clearInterval(silenceCheckInterval);
            }

            silenceCheckInterval = setInterval(checkSilence, CHECK_INTERVAL);
        };

        const stopSilenceDetection = () => {
            console.log('–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –¥–µ—Ç–µ–∫—Ü–∏–∏ –º–æ–ª—á–∞–Ω–∏—è');

            if (silenceCheckInterval) {
                clearInterval(silenceCheckInterval);
                silenceCheckInterval = null;
            }

            if (silenceTimer) {
                clearTimeout(silenceTimer);
                silenceTimer = null;
            }

            lastSoundTime = 0;
        };

        const startListening = async () => {
            console.log('–ù–∞—á–∞–ª–æ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è');

            manualClose = false;

            if (!wv || wv.readyState !== WebSocket.OPEN) {
                connectWS();
            }

            if (!stream && !(await setupMicrophone())) {
                output.textContent = '–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É';
                return;
            }

            isListening = true;
            button.textContent = 'üî¥ Stop Listening';
            output.textContent = '–°–ª—É—à–∞—é...';

            if (rec) {
                chunks = [];
                recordingStartTime = Date.now();
                rec.start();
                startSilenceDetection();
            }
        };

        const stopListening = () => {
            console.log('–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è');

            isListening = false;
            button.textContent = 'üéôÔ∏è Start Listening';
            output.textContent = '–û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ';

            stopSilenceDetection();

            if (rec && rec.state === 'recording') {
                rec.stop();
                chunks = [];
            }

            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
                isPlaying = false;
            }

            if (wv) {
                manualClose = true;
                wv.close();
                wv = null;
            }
        };

        button.onclick = () => {
            if (isListening) {
                stopListening();
            } else {
                startListening();
            }
        };

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && isPlaying) {
                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio = null;
                    isPlaying = false;

                    if (isListening && rec) {
                        rec.start();
                        startSilenceDetection();
                    }
                }
            }
        });

        connectWS();
    }
} 